## Embedded-systems-design-and-implementation
# UML design and C++ 
`AIMS: `
- To gain knowledge and experience of real-time embedded software design and implementation 

`INTENDED LEARNING OUTCOMES:`
1. Knowledge and Understanding 
- Apply a software development process for the object-oriented design and implementation of practical real-time embedded software systems.
2. Subject-Specific - Cognitive Skills 
- Design and implement a properly layered embedded software solution from the specification of a practical real-time embedded software problem. 
3. Subject-Specific - Practical Skills
- Design both the software device drivers for controlling hardware and the application software that uses these drivers.
- Implement a layered approach that separates the application, device driver and target platform software, while considering the real-time nature of the problems.
4. Key Transgerable Skills
- Apply suitable modular design and implementation approaches to engineering problems.

`CONTENT`
- UML design in its application to real-time systems.
- Use of association, aggregation and inheritance.
- Behavioural and structural diagram types.
- The C++ programming language.
- Variables, Bitwise manipulation of variables.
- Input/Output, operators, functions, call by value, call be reference, function overloading, variable scope, loops, conditionals.
- Pointers, dynamic memory allocation, arrays, file access, structures.
- Encapsulasion, polymorphism and inheritance in C++.
- C++ constructs required for real-time programming, "low-level" programming in C++.
- Solutions to achieve real-time operation in embedded enviroment: concurrency, polling, interupts.
- Volatile pointers, data strutures and classes to represent hardware interfaces.
- Introduction to device drivers and hardware control.
- Object-oriented model of device drivers.
- Use of compilation units in C++ to partition software.
- Layered and modular design principles, functional structuring of code.
- A layered approach to the design and implementation of software to permit portability across platforms and to ease the addition of new high-level features.
